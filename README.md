# Lab 5-1 walkthrough

## Practical Malware Analysis Labs- Ch.5 Lab

## In this lab we will analyze dll with **IDA** disassembler.

## Questions:

---
1- What is the address of DllMain?
Ok, so first i searched about main word in search section and found only **DllEntryPoint**, But i look at many writeups and answers and find that the location of the Main actually is different, it was **0x1000D02E**, if we jump to this location we will see this function
![](/images/miss_main.png)
and if we search on the prototype of **DllMain** on Microsoft we will see this 
![](/images/DllMain_Parameters.png)
and this is what i found in **DllEntryPoint**
![](/images/DllEntryPoint_Parameters.png)
So, i really was confused about this but i found this [article](https://reverseengineering.stackexchange.com/questions/30187/find-dllmain-using-ida-freeware) and figure out that this problem is happened cause of ida freeware and i try the solution inside it step by step and finally find **DllMain** 
![](/images/DllMain_Location.png)

**Answer: 0x1000D02E**

---
2- Use the Imports window to browse to gethostbyname. Where is the import
located?

So, we will open export window and press ctrl+f to search about **gethostbyname** and we find its location
![](/images/gethostbyname_loc.png)
**Answer: 0x100163CC**

---
3-How many functions call gethostbyname?

By pressing ctrl+x on this function we will find the total number of calling 
![](/images/total_number_of_calling.png)

**Answer: 18**

---

4-Focusing on the call to gethostbyname located at 0x10001757, can you fig-
ure out which DNS request will be made?

So, we will jump to this location and we will that gethostbyname calling in this location and if we explore this function we will see that it take a variable **name** and if we look above calling we will see that **eax** carries this name and at **0x1000174E** we will see **mov** instruction to this register by offset
![](/images/DNS.png)
if we look at this offset we will see this string
![](/images/url_req.png)
and we see **add** instruction to eax with **0D** which 13 so **eax** well moved along 13 bytes which we cause that the eax will be **pics.praticalmalwareanalysis.com** which is our DNS request.

**Answer: pics.praticalmalwareanalysis.com**

---

5-How many local variables has IDA Pro recognized for the subroutine at
0x10001656?

So, we will jump to this location and find this function 
![](/images/0x10001656_loc.png) <br>
this function takes one argument
and **23** local vars <br>
![](/images/locals.png) <br>

**Answer: 23**

---

6- How many parameters has IDA Pro recognized for the subroutine at
0x10001656? 

**Answer: 1**

---

7-Use the Strings window to locate the string \cmd.exe /c in the disassembly.
Where is it located?

So, we will open string window and search by this string and we will find its location.

![](/images/cmd_string.png)

**Answer: 0x10095B34**

---

8- What is happening in the area of code that references \cmd.exe /c? 

![](/images/what_happen.png)

We see that code will concatenate command line with this string to execute something, and if we data section we will see some catchy strings 
![](/images/catchy_strings.png)
![](/images/more_catchy_strings.png)

We will see something like **inject**, some strange messages and the most dangerous one is the **Remote Shell Session**

---

9- In the same area, at 0x100101C8, it looks like dword_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword_1008E5C4? (Hint: Use dword_1008E5C4â€™s cross-references.)

So, we will jump to this location and we will see comparing between our target and **ebx**. So, with the hint in question we will view cross-references to this dword  
![](/images/0x100101C8.png)
![](/images/cross-references.png)
we will see that in **sub_10001656** there is an assignment operation so let's go to this function <br>
![](/images/dword_1008E5C4_assignment.png)
<br>
we see that dword_1008E5C4 assigned with value in eax after calling function, so we can conclude that this varible carries the return value from this function, so let's dive into this function to see what it returns.

![](/images/PlatformId_comparing.png)
In this function we will see comparing **VersionInformation.dwPlatformId** with 2. And if we search about this field we will find that this is used to determine os version.
![](/images/Platform_id_doc.png)
and 2 meaning **The operating system is Windows NT or later** and then the code sets al to 1 if the condition matches and 0 if not and return. <br>
So we figure out that **dword_1008E5C4** set according to os version and this malware will act depends on this version.

---

10-A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?

So, if we jump to this subroutine we will find this logic
![](/images/Robotwork.png)
if the result from = zero, it will call this function
![](/images/ifzero.png)
By exploring this function we will find something interesting.
![](/images/sub_100052A2.png)
this function open registry key 
![](/images/RegOpenKeyExA.png)
and if its return value is zero (which mean key opened) it will jump to **short loc_10005309** <br>
In this location we will find this offest and calling
![](/images/RegQuery.png)

and if we search about this function we will find this doc
![](/images/RegQueryValueExA.png)

So, first we open registry key and then Query about its value
 
---

11- What does the export PSLIST do?

If we open Export window and search for PSLIST we will find its location and moving to it we will find this logic
![](/images/PSLIST.png)

First thing to notice that this function call **sub_100036C3** so if we dive into it 
![](/images/sub_100036C3.png)
We will find agian comparing VersionInformation.dwPlatformId with 2 which also check if windows version is is Windows NT or later and if not it will compare **dwMajorVersion** with 5 
![](/images/loc_100036FA%20.png)
and if we search about this field numbers we will find this
![](/images/dwMajorVersion.png)
it's search about os version again and depeneding on this it will call eaither **sub_1000664C** or **sub_10006518** 
![](/images/depend_on_version.png)

if we look at these functions we will see same thing they call a function called **CreateToolhelp32Snapshot** with **th32ProcessID** and **dwFlags** = 2
![](/images/CreateToolhelp32Snapshot.png)

and if we search about this function and parameters

![](/images/CreateToolhelp32Snapshot_doc.png)
![](/images/dwFlags.png)
So it will take a snapshot to all processes in the system

---

12- Use the graph mode to graph the cross-references from sub_10004E79.
Which API functions could be called by entering this function? Based on
the API functions alone, what could you rename this function? 

If we open graph mode for this function we will see these calls 
![](/images/sub_10004E79.png)
and the API called is **GetSystemDefaultLangID** which used to Returns the language identifier for the system locale, So we can call this function LangIdentifier.

---

13- How many Windows API functions does DllMain call directly? How many
at a depth of 2?

Actually IDA doesn't show me the xref graph so i can't answer this question :(

---

14- At 0x10001358, there is a call to Sleep (an API function that takes one
parameter containing the number of milliseconds to sleep). Looking
backward through the code, how long will the program sleep if this code
executes?

So, if we jump to this location and look above call we will see that **eax** used as argument to this function and above also there are some calculations and value moving to this register
![](/images/sleep_function.png)
So, if we look at offset that moved eax we will find this value
![](/images/sleep_offset.png) <br>
And back to function we can see **add** inst between eax and **0Dh** which is 13 in decimal. So after this addition eax will be **30** , and below this instruction there is a multiplication eax by **3E8h** which is 1000 in decimal. So in the end eax will be 30000 millisecond (30 second).

---

15- At 0x10001701 is a call to socket. What are the three parameters?

So jump to this location and you will see that above socket calling there are some values pushed
![](/images/socket.png)

---
16-Using the MSDN page for socket and the named symbolic constants func-
tionality in IDA Pro, can you make the parameters more meaningful?
What are the parameters after you apply changes?

After searching about Socket and renaming its parameters:

![](/images/AF.png)
![](/images/Type.png)
![](/images/Protocol.png)
![](/images/After_rename.png)

---
17-Search for usage of the in instruction (opcode 0xED). This instruction is
used with a magic string VMXh to perform VMware detection. Is that in use
in this malware? Using the cross-references to the function that executes
the in instruction, is there further evidence of VMware detection?

if we search for this opcode we will find this instruction 
![](/images/in_inst.png)
and by searchin about usage of this function we will find this document
![](/images/in_doc.png)
<br>
By tracing the value in eax we will find this value if we toggle it we will find that it's VMXH string 
![](/images/VMXH.png)
<br>
And if we use cross reference to function that calling this function we will see that this malware will cancel its installation if a virtual machine has been detected
![](/images/VM_detect.png)

---

18-Jump your cursor to 0x1001D988. What do you find?
If we jump to this location we will find some random data
![](/images/random_data.png)

---

Q19, Q20 and Q21 required IDA Pro and i have free edition so i can't solve these questions

---

So we finished this incredible challenge.<br>
I learned too much from it actually.<br>
So you guys in another challenge. 


